#pragma kernel CSMain

RWTexture2D<float4> Result;

int _OutputValue;

Texture2D _TerrainMap;
Texture2D _OutlineMap;

Texture2DArray _ProvinceMaps;
int _NumberOfProvinceMaps;

Texture2DArray _AreaMaps;
int _NumberOfAreaMaps;

SamplerState sampler_ProvinceMaps_RepeatPoint;
SamplerState sampler_ProvinceMaps;

struct NationShading
{
	int ProvinceMapIndex;
	int Selected;
	float3 ProvinceColor;
	float3 NationColor;
    float2 StartPoint;
    float2 EndPoint;
};

StructuredBuffer<NationShading> _ShadingData;
int _ShadingDataCount;

bool CompareColors(float3 colA, float3 colB)
{
	float Diff = 0.0f;

	Diff = abs(colA.r - colB.r);
	Diff += abs(colA.g - colB.g);
	Diff += abs(colA.b - colB.b);

	if (Diff < 0.15f)
		return true;
	else
		return false;
}

float4 ColorSwap(float4 Input, float3 From, float3 To)
{
	float Distance = CompareColors(From, Input.rgb);

	float4 Output = lerp(float4(0, 0, 0, 0), float4(To, 1), Distance);

	return lerp(Output, float4(0, 0, 0, 0), Input.a < 0.1f);
}

float3 QuickDiffTest(float3 InputCol, float3 ProvinceCol)
{
	return float3(abs(InputCol.r - ProvinceCol.r), abs(InputCol.g - ProvinceCol.g), abs(InputCol.b - ProvinceCol.b));
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	uint width, height;
	Result.GetDimensions(width, height);

	float2 uv = id.xy / float2(width, height) * 2 - 1;

	float4 OutputTex = float4(0, 0, 0, 0);

	if (_OutputValue == 0)
	{
		for (int x = 0; x < _NumberOfProvinceMaps; x++)
		{
			float4 NewTex = _ProvinceMaps.SampleLevel(sampler_ProvinceMaps_RepeatPoint, float3(uv * 0.5f + 0.5f, x), 0);
			OutputTex = lerp(NewTex, OutputTex, NewTex.a < 0.5f);
		}
	}
	else if (_OutputValue == 1)
	{
		for (int x = 0; x < _NumberOfAreaMaps; x++)
		{
			float4 NewTex = _AreaMaps.SampleLevel(sampler_ProvinceMaps_RepeatPoint, float3(uv * 0.5f + 0.5f, x), 0);
			OutputTex = lerp(NewTex, OutputTex, NewTex.a < 0.5f);
		}
	}
	else if (_OutputValue == 2)
	{
		for (int x = 0; x < _ShadingDataCount; x++)
		{
			float4 NewTex = _ProvinceMaps.SampleLevel(sampler_ProvinceMaps_RepeatPoint, float3(uv * 0.5f + 0.5f, _ShadingData[x].ProvinceMapIndex), 0);

			float4 col = ColorSwap(NewTex, _ShadingData[x].ProvinceColor, _ShadingData[x].NationColor);
			//float4 col = float4(QuickDiffTest(NewTex, _ShadingData[x].ProvinceColor), 1);

			OutputTex = lerp(col, OutputTex, OutputTex.a > 0.5f);
		}
	}
	else if (_OutputValue == 3)
	{
		float4 Terrain = _TerrainMap.SampleLevel(sampler_ProvinceMaps_RepeatPoint, float2(uv * 0.5f + 0.5f), 0);
		float4 Outline = _OutlineMap.SampleLevel(sampler_ProvinceMaps_RepeatPoint, float2(uv * 0.5f + 0.5f), 0);
		OutputTex = lerp(Terrain, Outline, Outline.a > 0.1f);
	}
	else if (_OutputValue == 4)
	{
		for (int x = 0; x < _ShadingDataCount; x++)
		{
			if (_ShadingData[x].Selected == 0)
				continue;

			float4 Province = _ProvinceMaps.SampleLevel(sampler_ProvinceMaps_RepeatPoint, float3(uv * 0.5f + 0.5f, _ShadingData[x].ProvinceMapIndex), 0);
			float4 Outline = _OutlineMap.SampleLevel(sampler_ProvinceMaps_RepeatPoint, float2(uv * 0.5f + 0.5f), 0);

			float4 col = ColorSwap(Province, _ShadingData[x].ProvinceColor, float3(0, 0, 0));

			OutputTex = lerp(float4(0, 0, 0, 0), float4(1, 1, 0, 1), Outline.a * col.a > 0.1f);
		}
	}

	Result[id.xy] = OutputTex;
}
